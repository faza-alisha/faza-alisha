# -*- coding: utf-8 -*-
"""FIX_TA_GSTAR_12 Lokasi_No Diff

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uAHMcuekae_iohQ-jmZvAt1FOXwLxXcu

# AK4093 - Tugas Akhir I
### Pemodelan GSTAR pada Produktivitas Padi

**1. *Import Library***
"""

import pandas as pd
import math
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
import scipy.stats as stats
import statsmodels.api as sm
from statsmodels.stats.diagnostic import acorr_ljungbox
from scipy.stats import shapiro
import pandas as pd

"""**2. Fungsi untuk membuat *dictionary* pengisi Matriks Bobot**"""

def count_two_distance(df,city1,city2):
  # -1 waktu indexing karena dia start dari 0 kalo start csv, sedangkan waktu kita nge create distance dict dari 1
  distances = math.sqrt((df["latitude"][city1-1]-df["latitude"][city2-1])**2+(df["longitude"][city1-1]-df["longitude"][city2-1])**2)
  return distances

def create_distance_dict(df):
  distances = {}
  for i in range(1, 11):
      for j in range(1, 11):
          if i != j:
              distances[(i, j)] = count_two_distance(df,i,j)
          else:
            distances[(i,j)]=0
  return distances

def find_max(distance):
  max_value=-9999999999
  for i in range(1,11) :
    for j in range (i+1,11):
      if(i!=j):
        if(distance[(i,j)]>max_value):
          max_value=distance[(i,j)]
  return max_value

def update_distances(distances, threshold,section):
    updated_distances = {}
    for start in range(1, 11):
        if section ==1 :
          length = sum(1 for end in range(1, 11) if start != end and 0<distances[(start, end)] < threshold)
        elif section == 2:
          length = sum(1 for end in range(1, 11) if start != end and threshold<distances[(start, end)] <= threshold*2)
        elif section == 3:
          length = sum(1 for end in range(1, 11) if start != end and threshold*2<distances[(start, end)] <= threshold*3)
        elif section == 4:
          length = sum(1 for end in range(1, 11) if start != end and threshold*3<distances[(start, end)] <= threshold*4)
        elif section == 5:
          length = sum(1 for end in range(1, 11) if start != end and threshold*4<distances[(start, end)] <= threshold*5)
        #param for this section =0
        else:
          length = sum(1 for end in range(1, 11) if start != end and distances[(start, end)]==0)
        for end in range(1, 11):
          if start != end:
            if section ==1 :
              if 0<distances[(start, end)] < threshold:
                updated_distances[(start, end)] = 1 / length if length > 0 else 0
              else:
                updated_distances[(start, end)] = 0
            elif section == 2:
              if threshold<distances[(start, end)] <= threshold*2:
                updated_distances[(start, end)] = 1 / length if length > 0 else 0
              else:
                updated_distances[(start, end)] = 0
            elif section == 3:
              if threshold*2<distances[(start, end)] <= threshold*3:
                updated_distances[(start, end)] = 1 / length if length > 0 else 0
              else:
                updated_distances[(start, end)] = 0
            elif section == 4:
              if threshold*3<distances[(start, end)] <= threshold*4:
                updated_distances[(start, end)] = 1 / length if length > 0 else 0
              else:
                updated_distances[(start, end)] = 0
            elif section == 5:
              if threshold*4<distances[(start, end)] <= threshold*5:
                updated_distances[(start, end)] = 1 / length if length > 0 else 0
              else:
                updated_distances[(start, end)] = 0
            else:
                updated_distances[(start, end)] = 1 / length if length > 0 else 0
    return updated_distances

"""**3. Import Data Jarak**"""

from google.colab import drive
drive.mount('/content/drive')

# File path in your Google Drive
file_path = '/content/drive/MyDrive/TA2/Jarak_Daerah_Jawa_Barat.xlsx'
sheet = 'Koordinat_10'

# Read the Excel file using pandas
import pandas as pd
data = pd.read_excel(file_path, sheet_name = sheet)
display(data)

# Now you can work with the 'data' DataFrame
# For example, if you want to create a distance dictionary, you need to define 'create_distance_dict' function and then call it passing 'data' DataFrame.
distances = create_distance_dict(data)

"""**4. Membangun Matriks Bobot**"""

#W1, W2, W3
updated_sections = {}
updated_sections_matrix={}
for i in range(1, 4):
    updated_sections[i] = update_distances(distances, find_max(distances) / 3, i)
    matrix = np.zeros((10, 10)) #jumlah
    for (k, j), value in updated_sections[i].items():
        matrix[k-1][j-1] = value
    updated_sections_matrix[i] = matrix

#updated_sections_matrix[<int->"ini adalah sectiion ke berapa start dari 1">][<int->"ini adalah row start dari 0">][<int->"ini adalah col start dari 0">]
print(updated_sections_matrix[3][2][1])
W1 = updated_sections_matrix[1]
W2 = updated_sections_matrix[2]
W3 = updated_sections_matrix[3]

#W0
W0 = np.eye(10)
print("Matriks W0 : ")
print(W0)
print("Matriks W1 : ")
print(W1)
print("Matriks W2 : ")
print(W2)
print("Matriks W3 : ")
print(W3)
print(distances)

"""**5. Import data Produktivitas Padi**"""

import pandas as pd

# File path in your Google Drive
file_path = '/content/drive/My Drive/TA2/data_TA2.xlsx'

# Specify the sheet name
sheet_name = 'Padi_Bulanan'  # Replace 'Sheet1' with the name of your sheet

# Read the Excel file with the specified sheet
data = pd.read_excel(file_path, sheet_name=sheet_name)

# Print the data
print(data)

"""

```
# This is formatted as code
```

**6. Pembagian Data** \
Akan dilakukan proses pemisahan antara data *train* dan data *test* dengan perbandingan 9:1 serta akan dilakukan pemusatan data."""

# Data Train (inget data start dari 0, column juga)
data_train = data.iloc[0:64, 1:11]

# Data Test
data_test = data.iloc[65:72, 1:11]

# Penggabungan Matriks Bobot
W=(W0,W1,W2,W3)

data_tp = np.transpose(data_train)
print(data_tp)

# Define Z
# Mengambil nama baris (indeks)
Z = data_tp.index.tolist()

# Menampilkan hasil
print("Nama Baris:")
print(Z)

"""**10. Estimasi Parameter** \
Akan dicari estimasi parameter dari beberapa model berikut: \


1.   GSTAR(1;1)
2.   GSTAR(1;2)
3.   GSTAR(1;3)
4.   GSTAR(2;1,1)
5.   GSTAR(2;1,2)
6.   GSTAR(2;2,1)
7.   GSTAR(2;2,2)
8.   GSTAR(3;1,1,1)
9.   GSTAR(3;1,1,2)
10.  GSTAR(3;1,2,1)
11.  GSTAR(3;2,1,1)
12.  GSTAR(3;1,2,2)
13.  GSTAR(3;2,1,2)
14.  GSTAR(3;2,2,1)
15.  GSTAR(3;2,2,2)



"""

def V(i,k,t,W,Z):
  V = 0
  Zt = Z.to_numpy()
  Wk = W[k]
  for j in range(len(Z)):
    V += Wk[i][j]*Zt[j][t]
  return V

def Y(p,Z):
  Y = Z.iloc[:,p:]
  Y = Y.to_numpy()
  Y = Y.reshape((len(Z)*(len(Z.columns)-p),1))
  return Y

def Xi(i,p,sp_or,W,Z):
  X = []
  for f in range(p-1,len(Z.columns)-1):
    u = []
    for g in range(p):
      for h in range(sp_or[g]+1):
        u.append(V(i,h,f-g,W,Z))
    X.append(u)
  return np.array(X)

def X(p,sp_or,W,Z):
  Xi_list = []
  for i in range(len(Z)):
    Xi_list.append(Xi(i,p,sp_or,W,Z))
  a = len(Z.columns) - p
  b = p + np.sum(sp_or)
  zeros = np.zeros((a,b))
  X = [[zeros for j in range(len(Xi_list))] for i in range(len(Xi_list))]
  for j in range(len(Xi_list)):
    X[j][j] = Xi_list[j]
  return np.block(X)

def GSTAR(p,sp_or,W,Z):
  global err
  global pred
  global est
  global result
  Ys = Y(p,Z)
  Xs = X(p,sp_or,W,Z)
  XTX_inv = np.linalg.inv(Xs.T@Xs)
  est = XTX_inv@Xs.T@Ys
  Par = []
  for i in range(p):
    for j in range(sp_or[i]+1):
      for k in range(len(Z)):
        Par.append("$\phi_{"+str(i+1)+str(j)+"}^{("+str(k+1)+")}$")
  Par = np.array(Par).reshape((len(est),1))
  pred = Xs@est
  err = Ys - pred
  SSE = (err.T)@err
  MSE = SSE/(len(Ys)-len(Xs[0]))
  se = np.array([(MSE[0]*XTX_inv[i][i])**0.5 for i in range(len(est))]).reshape((len(est),1))
  T = np.array([est[i]/(MSE[0]*XTX_inv[i][i])**0.5 for i in range(len(est))]).reshape((len(est),1))
  P = [0 for i in range(len(est))]
  sign = [0 for i in range(len(est))]
  for i in range(len(est)):
    if T[i] > 0:
      P[i] = 2*(1-stats.t.cdf(T[i],len(Ys)-len(Xs[0])))
    else:
      P[i] = 2*(stats.t.cdf(T[i],len(Ys)-len(Xs[0])))
    if P[i] < 0.05:
      sign[i] = 'Significant'
    else:
      sign[i] = 'Insignificant'
  P = np.array(P).reshape((len(est),1))
  sign = np.array(sign).reshape((len(est),1))
  result = pd.DataFrame({'Parameter' : Par.reshape(len(est)),  'Estimate' : est.reshape(len(est)), 'Std. Error' : se.reshape(len(est)),
                       't Value' : T.reshape(len(est)), 'Pr > |t|' : P.reshape(len(est)), 'Significance' : sign.reshape(len(est))})
  MAPE = 0
  dev = 0
  for i in range(len(pred)):
    MAPE += np.abs(Ys[i]-pred[i])/np.abs(Ys[i])
    dev += np.abs(Ys[i]-np.mean(Ys))
  MASE = sum(np.abs(err))/dev
  return print("AIC:",(len(Ys)*np.log(MSE)+2*len(est))[0][0]), print("RMSE:", np.sqrt(MSE[0][0])), print("MAPE: "+str(MAPE[0]*100/len(Ys))+"%"), print("MASE:", MASE[0]), print(result)

"""1 - GSTAR(1;1)"""

# Display all columns
pd.set_option('display.max_columns', None)

# Display all rows
pd.set_option('display.max_rows', None)

# Display the full width of each column
pd.set_option('display.max_colwidth', None)
GSTAR(1, [1], W, data_tp)

result['Significance'].value_counts()

pred_loc = [[0 for i in range(int(len(pred)/len(data_tp)))] for i in range(len(data_tp))]
j = 0
k = 0
for i in range(len(pred)):
    if (i+1)%(int(len(pred)/len(data_tp))) != 0:
        pred_loc[j][k] = np.concatenate(pred)[i]
        k += 1
    else:
        pred_loc[j][k] = np.concatenate(pred)[i]
        k = 0
        j += 1
pd.DataFrame(pred_loc)

# coba versi yang jangan diferensi

plt.rcParams["figure.figsize"] = (16,12)
figure, axis = plt.subplots(2, 2)
axis[0][0].plot(pred_loc[0], marker = 'o', label = 'Predicted')
axis[0][0].plot(np.array(data_tp)[0][2:], marker = 'o', label = 'Actual', c = 'red')
axis[0][0].set_title('Predicted vs Actual - Bandung Barat', fontsize = 16)
axis[0][0].set_xlabel('Week', fontsize = 14)
axis[0][0].set_ylabel('Produktivitas Padi', fontsize = 14)
axis[0][0].set_xticks(np.arange(len(pred_loc[0]),step=6), np.arange(6, len(pred_loc[0])+6,step=6))
axis[0][0].legend(loc='lower left')

axis[0][1].plot(pred_loc[1], marker = 'o', label = 'Predicted')
axis[0][1].plot(np.array(data_tp)[1][2:], marker = 'o', label = 'Actual', c = 'red')
axis[0][1].set_title('Predicted vs Actual - Bandung', fontsize = 16)
axis[0][1].set_xlabel('Week', fontsize = 14)
axis[0][1].set_ylabel('Produktivitas Padi', fontsize = 14)
axis[0][1].set_xticks(np.arange(len(pred_loc[0]),step=6), np.arange(6, len(pred_loc[0])+6,step=6))
axis[0][1].legend(loc='lower left')

axis[1][0].plot(pred_loc[2], marker = 'o', label = 'Predicted')
axis[1][0].plot(np.array(data_tp)[2][2:], marker = 'o', label = 'Actual', c = 'red')
axis[1][0].set_title('Predicted vs Actual - Bogor', fontsize = 16)
axis[1][0].set_xlabel('Week', fontsize = 14)
axis[1][0].set_ylabel('Produktivitas Padi', fontsize = 14)
axis[1][0].set_xticks(np.arange(len(pred_loc[0]),step=6), np.arange(6, len(pred_loc[0])+6,step=6))
axis[1][0].legend(loc='lower left')

axis[1][1].plot(pred_loc[3], marker = 'o', label = 'Predicted')
axis[1][1].plot(np.array(data_tp)[3][2:], marker = 'o', label = 'Actual', c = 'red')
axis[1][1].set_title('Predicted vs Actual - Ciamis', fontsize = 16)
axis[1][1].set_xlabel('Week', fontsize = 14)
axis[1][1].set_ylabel('Produktivitas Padi', fontsize = 14)
axis[1][1].legend(loc='lower left')
axis[1][1].set_xticks(np.arange(len(pred_loc[0]),step=6), np.arange(6, len(pred_loc[0])+6,step=6))
plt.show()

plt.rcParams["figure.figsize"] = (16,12)
figure, axis = plt.subplots(2, 2)
axis[0][0].plot(pred_loc[4], marker = 'o', label = 'Predicted')
axis[0][0].plot(np.array(data_tp)[5][2:], marker = 'o', label = 'Actual', c = 'red')
axis[0][0].set_title('Predicted vs Actual - Cianjur', fontsize = 16)
axis[0][0].set_xlabel('Week', fontsize = 14)
axis[0][0].set_ylabel('Produktivitas Padi', fontsize = 14)
axis[0][0].set_xticks(np.arange(len(pred_loc[0]),step=6), np.arange(6, len(pred_loc[0])+6,step=6))
axis[0][0].legend(loc='lower left')

axis[0][1].plot(pred_loc[5], marker = 'o', label = 'Predicted')
axis[0][1].plot(np.array(data_tp)[6][2:], marker = 'o', label = 'Actual', c = 'red')
axis[0][1].set_title('Predicted vs Actual - Cirebon', fontsize = 16)
axis[0][1].set_xlabel('Week', fontsize = 14)
axis[0][1].set_ylabel('Produktivitas Padi', fontsize = 14)
axis[0][1].set_xticks(np.arange(len(pred_loc[0]),step=6), np.arange(6, len(pred_loc[0])+6,step=6))
axis[0][1].legend(loc='lower left')

axis[1][0].plot(pred_loc[6], marker = 'o', label = 'Predicted')
axis[1][0].plot(np.array(data_tp)[7][2:], marker = 'o', label = 'Actual', c = 'red')
axis[1][0].set_title('Predicted vs Actual - Garut', fontsize = 16)
axis[1][0].set_xlabel('Week', fontsize = 14)
axis[1][0].set_ylabel('Produktivitas Padi', fontsize = 14)
axis[1][0].set_xticks(np.arange(len(pred_loc[0]),step=6), np.arange(6, len(pred_loc[0])+6,step=6))
axis[1][0].legend(loc='lower left')

axis[1][1].plot(pred_loc[7], marker = 'o', label = 'Predicted')
axis[1][1].plot(np.array(data_tp)[8][2:], marker = 'o', label = 'Actual', c = 'red')
axis[1][1].set_title('Predicted vs Actual - Sukabumi', fontsize = 16)
axis[1][1].set_xlabel('Week', fontsize = 14)
axis[1][1].set_ylabel('Produktivitas Padi', fontsize = 14)
axis[1][1].legend(loc='lower left')
axis[1][1].set_xticks(np.arange(len(pred_loc[0]),step=6), np.arange(6, len(pred_loc[0])+6,step=6))
plt.show()

plt.rcParams["figure.figsize"] = (16, 6)
figure, axis = plt.subplots(1, 2)  # Adjusted to create 1 row and 2 columns of subplots

axis[0].plot(pred_loc[8], marker='o', label='Predicted')
axis[0].plot(np.array(data_tp)[8][2:], marker='o', label='Actual', c='red')
axis[0].set_title('Predicted vs Actual - Sumedang', fontsize=16)
axis[0].set_xlabel('Week', fontsize=14)
axis[0].set_ylabel('Produktivitas Padi', fontsize=14)
axis[0].set_xticks(np.arange(len(pred_loc[0]), step=6), np.arange(6, len(pred_loc[0]) + 6, step=6))
axis[0].legend(loc='lower left')

axis[1].plot(pred_loc[9], marker='o', label='Predicted')
axis[1].plot(np.array(data_tp)[9][2:], marker='o', label='Actual', c='red')
axis[1].set_title('Predicted vs Actual - Tasikmalaya', fontsize=16)
axis[1].set_xlabel('Week', fontsize=14)
axis[1].set_ylabel('Produktivitas Padi', fontsize=14)
axis[1].set_xticks(np.arange(len(pred_loc[0]), step=6), np.arange(6, len(pred_loc[0]) + 6, step=6))
axis[1].legend(loc='lower left')

plt.tight_layout()
plt.show()

"""**11. Uji Diagnostik** \
Selanjutnya, akan dilakukan uji diagnostik sebagai berikut:
"""

err_loc = [[0 for i in range(int(len(err)/len(data_tp)))] for i in range(len(data_tp))]
j = 0
k = 0
for i in range(len(err)):
    if (i+1)%(int(len(err)/len(data_tp))) != 0:
        err_loc[j][k] = np.concatenate(err)[i]
        k += 1
    else:
        err_loc[j][k] = np.concatenate(err)[i]
        k = 0
        j += 1
pd.DataFrame(err_loc)

plt.hist(err_loc[0], edgecolor='black')
plt.show()

# Assuming data_tp is a list of lists or a numpy array
first_row_data_tp = data_tp[0]  # Accessing the first row

diagnostic = [[0 for j in range(4)] for i in range(len(data_tp))]  # Assuming you only need 4 columns
for i in range(len(data_tp)):
    diagnostic[i][0] = first_row_data_tp[0]  # Assigning values from the first row of data_tp for the first column
    for j in range(1, 4):  # Accessing columns from the second to the 11th
        diagnostic[i][j] = first_row_data_tp[j + 1]  # Assigning values from the first row of data_tp

    diagnostic[i][1] = round(float(acorr_ljungbox(err_loc[i], lags=[1]).lb_pvalue), 4)
    diagnostic[i][2] = round(float(shapiro(err_loc[i]).pvalue), 4)
    if diagnostic[i][1] < 0.05 or diagnostic[i][2] < 0.05:
        diagnostic[i][3] = 'Inadequate'
    else:
        diagnostic[i][3] = 'Adequate'

diagnostic = pd.DataFrame(diagnostic, columns=['Location', 'Ljung-Box (P-Value)', 'Shapiro-Wilk(P-Value)', 'Model Adequacy'])
diagnostic

def Ci(i,err):
    C = 0
    for j in range(i,len(err[0])):
        C += np.array(err).T[j].reshape((len(err),1))@np.array(err).T[j-i].reshape((1,len(err)))
    return C/len(err[0])

def Qh(h, err):
    Q = 0
    for i in range(1,h+1):
        Q += np.trace(np.transpose(Ci(h,err))@np.linalg.inv(Ci(0,err))@Ci(h,err)@np.linalg.inv(Ci(0,err)))/(len(err[0])-i)
    return Q*(len(err[0])**2)

def PortmanteauTest(lags,err):
    pt = [[0 for j in range(3)] for i in range(lags)]
    for i in range(lags):
        pt[i][0] = i+1
        pt[i][1] = Qh(i+1,err)
        pt[i][2] = 1 - stats.chi2.cdf(pt[i][1], (len(err_loc)**2)*(i+1))
    pt = pd.DataFrame(pt)
    pt.columns = ['Lags', 'Portmanteau Statistic (Qh)', 'P-Value']
    return pt

PortmanteauTest(10, err_loc)

e_bar = [sum(err_loc[i])/len(err_loc[i]) for i in range(len(err_loc))]
s_e = 0
for i in range(len(err_loc[0])):
    s_e += (np.array(err_loc).T[i]-e_bar).reshape((len(err_loc),1))@(np.array(err_loc).T[i]-e_bar).T.reshape((1,len(err_loc)))
Ps = np.linalg.cholesky(s_e)
vt = []
for i in range(len(err_loc[0])):
    vt.append(np.linalg.inv(Ps)@(np.array(err_loc).T[i]-e_bar).reshape((len(err_loc),1)))
b1 = []
b2 = []
b1_count = 0
b2_count = 0
for i in range(len(vt[0])):
    for j in range(len(vt)):
        b1_count += (vt[j][i]**3)/len(vt)
        b2_count += (vt[j][i]**4)/len(vt)
    b1.append(b1_count)
    b2.append(b2_count)
    b1_count = 0
    b2_count = 0
b1 = np.concatenate(b1)
b2 = np.concatenate(b2)

lambda_s = len(vt)*(np.array(b1).T@np.array(b1))/6
lambda_k = len(vt)*((np.array(b2)-np.array([3 for i in range(len(vt[0]))])).T@(np.array(b2)-np.array([3 for i in range(len(vt[0]))])))/24
lambda_sk = lambda_s + lambda_k

print('P-Value:', 1 - stats.chi2.cdf(lambda_sk, 2*len(vt[0])**2))

phi = [[0 for j in range(len(Z))] for i in range(int(len(est)/len(Z)))]
j = 0
k = 0
for i in range(len(est)):
    if (i+1)%(len(Z)) != 0:
        phi[j][k] = np.concatenate(est)[i]
        k += 1
    else:
        phi[j][k] = np.concatenate(est)[i]
        k = 0
        j += 1

p = 2
sp_or = [3,1]
Bs = []
k = 0
for i in range(p):
    B = 0
    for j in range(sp_or[i]+1):
        B += np.diag(phi[k])@W[j]
        k += 1
    Bs.append(B)
I = np.identity(10)
O = np.zeros((10,10))
B = [[O for j in range(p)] for i in range(p)]
for i in range(p):
    for j in range(p):
        if i == 0:
            B[i][j] = Bs[j]
        else:
            B[i][i-1] = I
B = np.block(B)

if max(abs(np.linalg.eigvals(B))) < 1:
    print('Max Absolute Eigenvalue:', max(abs(np.linalg.eigvals(B))))
    print('Model is stationary')
else:
    print('Max Absolute Eigenvalue:', max(abs(np.linalg.eigvals(B))))
    print('Model is nonstationary')

"""**12. Forecasting**"""

phi = [[0 for j in range(len(Z))] for i in range(int(len(est)/len(Z)))]
j = 0
k = 0
for i in range(len(est)):
    if (i+1)%(len(Z)) != 0:
        phi[j][k] = np.concatenate(est)[i]
        k += 1
    else:
        phi[j][k] = np.concatenate(est)[i]
        k = 0
        j += 1
pd.DataFrame(phi)

# Given data
a = [6, 7, 3, 4, 5]

# AR(1) parameter
phi = 0.7

# Function to predict next values recursively
def predict_next(data, phi, steps):
    predictions = []
    for _ in range(steps):
        next_val = (phi + 1) * data[-1] - phi * data[-2]
        predictions.append(next_val)
        data.append(next_val)
    return predictions

# Predict next 5 values
predictions = predict_next(a[-2:], phi, 5)
print(predictions)